/*
Title: script.c
Author: Justin Staples (001052815)
Parnter: Mahmoud Khattab (000853210)
Date: February 5th, 2018
Usage: gcc -o script script.c

A recursive descent parser for the following EBNF grammar, with E as the
starting symbol. This program will parse and evaluate arithmetic and 
boolean expressions, and will return an error if an invalid character
or a type mismatch is detected. Commented above each production function
are the attribute rules, which assign values and types to expressions. 

This grammar is an extended version of the grammar found on page 111 of 
the course notes. It adds productions to include boolean operators. It also
adds the non-terminals 'D' and 'B', which produce the valid symbols for 
each data type. 

E   ->   T { ('+' | '-' | '=' | '#') T }
T   ->   F { ('*' | '/' | '|' | '&') F }
F   ->   I | '(' E ')' | ['~'] B
I   ->   D { D }
D   ->   '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' 
B   ->   't' | 'f'

Here are some examples of sentences that are accepted by the grammar, with
their attributes shown below:

2+3
type: integer
val: 5

(((14)))*(4-3)+7/7
type: integer
val: 15

t&t
type: boolean
val: 1

(t=f)|(f#f)=~f&((t=t))
type: boolean
val: 0

1+t
type: error
val: n/a

10/6=t#t
type: error
val: n/a
*/

#include <stdio.h> // input/output
#include <ctype.h> // isalpha, isdigit
#include <stdlib.h>  // malloc

// global variable declarations
int charClass; // group the keyboard characters into classes
char nextChar; // read the next character in the sentence
int nextToken; // identify the next token in the sentence
int accepted; // determine if the sentence is accepted by the language
char sentence[100]; // user input is stored in this variable
int counter = 0; // counter for iterating through the sentence

// structure for holding the value and type attributes
typedef struct {
	int value;
	int type;
} AttrSet;

// forward declaration for E because the productions for F involve E, but E appears last
void E(AttrSet * as);

// character classes
#define LETTER 2
#define DIGIT 1
#define OTHER 99

// token codes
#define INT_LIT 10
#define BOO 11
#define PLUS_OP 12
#define MINUS_OP 13
#define TIMES_OP 14
#define DIV_OP 15
#define LEFT_PAREN 16
#define RIGHT_PAREN 17
#define EQUALITY 18
#define INEQUALITY 19
#define PIPE 20
#define AMPERSAND 21
#define NEGATION 22
#define EOS 23

// lookup table for special characters that have their own token code
int lookup(char ch) {
	switch (ch) {
		case '+':
			nextToken = PLUS_OP;
			break;
		case '-':
			nextToken = MINUS_OP;
			break;
		case '*':
			nextToken = TIMES_OP;
			break;
		case '/':
			nextToken = DIV_OP;
			break;
		case '(':
			nextToken = LEFT_PAREN;
			break;
		case ')':
			nextToken = RIGHT_PAREN;
			break;
		case '=':
			nextToken = EQUALITY;
			break;
		case '#':
			nextToken = INEQUALITY;
			break;
		case '|':
			nextToken = PIPE;
			break;
		case '&':
			nextToken = AMPERSAND;
			break;
		case '~':
			nextToken = NEGATION;
			break;
		case '\0':
			nextToken = EOS;
			break;
		default:
			accepted = 0;
	}
	return nextToken;
}

// grabs the next character in the input sentence and assigns it the correct character class
void get() {
	nextChar = sentence[counter++];
	if (isalpha(nextChar)) {
		charClass = LETTER;
	} else if (isdigit(nextChar)) {
		charClass = DIGIT;
	} else {
		charClass = OTHER;
	}
}

// lex grabs the next character and then uses the character class to assign the correct token
int lex() {
	get();

	switch (charClass) {
		case LETTER:
			switch (nextChar) {
				case 't':
				case 'f':
					nextToken = BOO;
					break;
				default:
					accepted = 0;
			} 
			break;
		case DIGIT:
			nextToken = INT_LIT;
			break;
		case OTHER:
			lookup(nextChar);
			break;
	}
	return nextToken;
}

/*
parses terms in the language generated by the production B (boolean)

boolean(v0, t0) :: = "t"
	<< v0 = True >>
	<< t0 = boolean >>

boolean(v0, t0) :: = "f"
	<< v0 = False >>
	<< t0 = boolean >>
*/
void B(AttrSet * as) {
	switch (nextChar) {
		case 't':
			as->value = 1;
			as->type = 0;
			break;
		case 'f':
			as->value = 0;
			as->type = 0;
			break;
		default:
			accepted = 0;
	}
	lex();
}

/*
parses terms in the language generated by the production D (digit)

digit(v0, t0) :: = "0"
	<< v0 = 0 >>
	<< t0 = integer >>

digit(v0, t0) :: = "1"
	<< v0 = 1 >>
	<< t0 = integer >>

digit(v0, t0) :: = "2"
	<< v0 = 2 >>
	<< t0 = integer >>

digit(v0, t0) :: = "3"
	<< v0 = 3 >>
	<< t0 = integer >>

digit(v0, t0) :: = "4"
	<< v0 = 4 >>
	<< t0 = integer >>

digit(v0, t0) :: = "5"
	<< v0 = 5 >>
	<< t0 = integer >>

digit(v0, t0) :: = "6"
	<< v0 = 6 >>
	<< t0 = integer >>

digit(v0, t0) :: = "7"
	<< v0 = 7 >>
	<< t0 = integer >>

digit(v0, t0) :: = "8"
	<< v0 = 8 >>
	<< t0 = integer >>

digit(v0, t0) :: = "9"
	<< v0 = 9 >>
	<< t0 = integer >>
*/
void D(AttrSet * as) {
	as->value = atoi(&nextChar);
	as->type = 1;
	lex();
}

/*
parses terms in the language generated by the production I (integer)

integer(v0, t0) :: = digit(v1, t1) 
	<< v0 = v1 >>
	<< t0 = t1 >

integer(v0, t0) :: = digit(v1, t1) digit(v2, t2)
	<< v0 = (10 * v1) + v2 >>
	<< t0 = t1 >
*/
void I(AttrSet * as) {
	AttrSet * as1 = (AttrSet *) malloc(sizeof(AttrSet));
	AttrSet * as2 = (AttrSet *) malloc(sizeof(AttrSet));
	D(as1);
	while (nextToken == INT_LIT) {
		D(as2);
		as1->value = 10 * as1->value + as2->value;
	}

	as->value = as1->value;
	as->type = as1->type;

	free(as1);
	free(as2);
}

/*
parses terms in the language generated by the production F (factor)

factor(v0, t0) :: = integer(v1, t1)  
	<< v0 = v1 >>
	<< t0 = t1 >>

factor(v0, t0) :: = "(" expression(v1, t1) ")" 
	<< v0 = v1 >>
	<< t0 = t1 >>

factor(v0, t0) :: = ["~"] boolean(v1, t1)
	if nextToken = "~":
		<< v0 = ~ v1 >>
		<< t0 = t1 >>
	else:
		<< v0 = v1 >>
		<< t0 = t1 >>	
*/
void F(AttrSet * as) {
	AttrSet * as1 = (AttrSet *) malloc(sizeof(AttrSet));

	switch (nextToken) {
		case INT_LIT:
			I(as1);
			break;
		case LEFT_PAREN:
			lex();
			E(as1);
			if (nextToken == RIGHT_PAREN) {
				lex();
			} else {
				accepted = 0;
				return;
			}
			break;
		case NEGATION:
		case BOO:
			if (nextToken == NEGATION) {
				lex();
				B(as1);
				if (as1->value == 0) {
					as1->value = 1;
				} else {
					as1->value = 0;
				}
			} else {
				B(as1);
			}
			break;
		default:
			accepted = 0;
	}

	as->value = as1->value;
	as->type = as1->type;
	free(as1);

}

/*
parses terms in the language generated by the production T (term)

term(v0, t0) :: = factor(v1, t1) 
	<< v0 = v1 >>
	<< t0 = t1 >>

term(v0, t0) :: = factor(v1, t1) "*" factor(v2, t2) 
	if t1 = integer and t2 = integer:
		<< v0 = v1 * v2 >>
		<< t0 = t1 >>
	else:
		error

term(v0, t0) :: = factor(v1, t1) "*" factor(v2, t2) 
	if t1 = integer and t2 = integer:
		<< v0 = v1 / v2 >>
		<< t0 = t1 >>
	else:
		error

term(v0, t0) :: = factor(v1, t1) "|" factor(v2, t2) 
	if t1 = boolean and t2 = boolean:
		<< v0 = v1 || v2 >>
		<< t0 = t1 >>
	else:
		error

term(v0, t0) :: = factor(v1, t1) "&" factor(v2, t2) 
	if t1 = boolean and t2 = boolean:
		<< v0 = v1 && v2 >>
		<< t0 = t1 >>
	else:
		error
*/
void T(AttrSet * as) {
	AttrSet * as1 = (AttrSet *) malloc(sizeof(AttrSet));
	AttrSet * as2 = (AttrSet *) malloc(sizeof(AttrSet));
	F(as1);

	while (nextToken == TIMES_OP || nextToken == DIV_OP || nextToken == PIPE || nextToken == AMPERSAND) {
		switch (nextToken) {
			case TIMES_OP:
				lex();
				F(as2);
				if (as1->type == 1 && as2->type == 1) {
					as1->value *= as2->value;
				} else {
					accepted = 0;
				}
				break;
			case DIV_OP:
				lex();
				F(as2);
				if (as1->type == 1 && as2->type == 1) {
					as1->value /= as2->value;
				} else {
					accepted = 0;
				}
				break;
			case PIPE:
				lex();
				F(as2);
				if (as1->type == 0 && as2->type == 0) {
					as1->value = (as1->value || as2-> value) ? 1 : 0;
				} else {
					accepted = 0;
				}
				break;
			case AMPERSAND:
				lex();
				F(as2);
				if (as1->type == 0 && as2->type == 0) {
					as1->value = (as1->value && as2-> value) ? 1 : 0;
				} else {
					accepted = 0;
				}
				break;
		}
	}

	as->value = as1->value;
	as->type = as1->type;
	free(as1);
	free(as2);
}

/*
parses terms in the language generated by the production E (expression)

expression(v0, t0) :: = term(v1, t1) 
	<<v0 = v1>>
	<<t0 = t1>>

expression(v0, t0) :: = expression(v1, t1) "+" term(v2, t2) 
	if t1 = integer and t2 = integer:
		<< v0 = v1 + v2 >>
		<< t0 = integer >>
	else:
		error

expression(v0, t0) :: = expression(v1, t1) "-" term(v2, t2) 
	if t1 = integer and t2 = integer:
		<< v0 = v1 - v2 >>
		<< t0 = integer >>
	else:
		error

expression(v0, t0) :: = expression(v1, t1) "=" term(v2, t2) 
	if t1 = boolean and t2 = boolean:
		<< v0 = (v1 == v2) >>
		<< t0 = boolean >>
	else:
		error

expression(v0, t0) :: = expression(v1, t1) "#" term(v2, t2) 
	if t1 = boolean and t2 = boolean:
		<< v0 = (v1 != v2) >>
		<< t0 = boolean >>
	else:
		error
*/
void E(AttrSet * as) {
	AttrSet * as1 = (AttrSet *) malloc(sizeof(AttrSet));
	AttrSet * as2 = (AttrSet *) malloc(sizeof(AttrSet));
	T(as1);

	while (nextToken == PLUS_OP || nextToken == MINUS_OP || nextToken == EQUALITY || nextToken == INEQUALITY) {
		switch (nextToken) {
			case PLUS_OP:
				lex();
				T(as2);
				if (as1->type == 1 && as2->type == 1) {
					as1->value += as2->value;
				} else {
					accepted = 0;
				}
				break;
			case MINUS_OP:
				lex();
				T(as2);
				if (as1->type == 1 && as2->type == 1) {
					as1->value -= as2->value;
				} else {
					accepted = 0;
				}
				break;
			case EQUALITY:
				lex();
				T(as2);
				if (as1->type == 0 && as2->type == 0) {
					as1->value = (as1->value == as2->value) ? 1 : 0;
				} else {
					accepted = 0;
				}
				break;
			case INEQUALITY:
				lex();
				T(as2);
				if (as1->type == 0 && as2->type == 0) {
					as1->value = (as1->value != as2->value) ? 1 : 0;
				} else {
					accepted = 0;
				}
				break;
		}
	}

	as->value = as1->value;
	as->type = as1->type;

	free(as1);
	free(as2);
}

int main() {
	// automatically assume that every word will be accepted. Once a bad character or type mismatch is recognized, set accepted = 0
	accepted = 1; 
	AttrSet * as = (AttrSet *) malloc(sizeof(AttrSet)); 

	// grab sentence from user input
	printf("Please type the sentence that you would like to test, then press Enter\n");
	scanf("%s", sentence);

	// grab the first symbol and then begin parsing
	lex();
	E(as);

	// if the string is accepted, print the attributes, otherwise print error
	if (accepted && nextToken == EOS) {
		if (as->type == 0) {
			printf("type: boolean\n");
		} else {
			printf("type: integer\n");
		}
		printf("val: %d\n", as->value);
	} else {
		printf("type: error\n");
		printf("val: n/a\n");
	}

	free(as);

	return 0;
}




















